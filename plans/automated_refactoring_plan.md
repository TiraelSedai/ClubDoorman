# –ü–ª–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –¥–ª—è C# ClubDoorman

## –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è C# –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏

### üîß –ó—Ä–µ–ª—ã–µ AST-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã

| –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç | –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ | –°—Ç–∞—Ç—É—Å |
|------------|-------------|--------|
| **dotnet-format** | –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ | ‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω |
| **Roslyn Analyzers** | –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä—ã | ‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ |
| **JetBrains ReSharper** | –ú–æ—â–Ω—ã–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∏ | ‚úÖ –ï—Å—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è |
| **Visual Studio Refactoring** | –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∏ | ‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ |
| **Roslynator** | –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∏ | ‚è≥ –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å |

### üöÄ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ–º—ã–µ –∑–∞–¥–∞—á–∏

#### 1. **–ü–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏** (100% –±–µ–∑ –≤–º–µ—à–∞—Ç–µ–ª—å—Å—Ç–≤)

**–î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞:**
```bash
# –°–æ–∑–¥–∞–Ω–∏–µ —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤
dotnet new class -n UserUtils -o ClubDoorman/Infrastructure/
dotnet new class -n MessageUtils -o ClubDoorman/Infrastructure/
```

**–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤:**
```bash
# Roslyn –º–æ–∂–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –º–µ—Ç–æ–¥—ã –º–µ–∂–¥—É –∫–ª–∞—Å—Å–∞–º–∏
# –∏ –æ–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ —Å—Å—ã–ª–∫–∏
```

**–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ:**
```bash
# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –≤—Å–µ—Ö —Å—Å—ã–ª–æ–∫
# —á–µ—Ä–µ–∑ IDE –∏–ª–∏ Roslyn
```

#### 2. **AI-–≤ –ø–æ–º–æ—â—å** (—Ç—Ä–µ–±—É–µ—Ç —Ä–µ–≤—å—é)

**–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –±–æ–ª—å—à–∏—Ö –∫–ª–∞—Å—Å–æ–≤:**
- AI –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –ø–ª–∞–Ω —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
- AST-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤—ã–ø–æ–ª–Ω—è—é—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

**–í—ã–Ω–æ—Å –æ–±—â–∏—Ö —É—Ç–∏–ª–∏—Ç:**
- AI –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥
- Roslyn –≤—ã–ø–æ–ª–Ω—è–µ—Ç —ç–∫—Å—Ç—Ä–∞–∫—Ü–∏—é

## –≠—Ç–∞–ø 1: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞

### 1.1 –î–æ–±–∞–≤–∏—Ç—å –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä—ã –≤ –ø—Ä–æ–µ–∫—Ç

```xml
<!-- –î–æ–±–∞–≤–∏—Ç—å –≤ ClubDoorman.csproj -->
<ItemGroup>
  <PackageReference Include="Microsoft.CodeAnalysis.NetAnalyzers" Version="9.0.0">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  </PackageReference>
  <PackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.507">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  </PackageReference>
  <PackageReference Include="Roslynator.Analyzers" Version="4.7.0">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  </PackageReference>
</ItemGroup>
```

### 1.2 –°–æ–∑–¥–∞—Ç—å .editorconfig –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏

```ini
# .editorconfig
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.cs]
indent_style = space
indent_size = 4

# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion
dotnet_style_require_accessibility_modifiers = for_non_interface_members:suggestion
dotnet_style_readonly_field = true:suggestion

# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ using
dotnet_style_unused_using_directive = true:suggestion
```

## –≠—Ç–∞–ø 2: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è

### 2.1 –°–æ–∑–¥–∞—Ç—å Roslyn Analyzer –¥–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è

```csharp
// Analyzers/DuplicateCodeAnalyzer.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class DuplicateCodeAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "CD001";
    
    private static readonly LocalizableString Title = "Duplicate code detected";
    private static readonly LocalizableString MessageFormat = "Method '{0}' is duplicated in multiple files";
    
    private static readonly DiagnosticDescriptor Rule = new(
        DiagnosticId, Title, MessageFormat, 
        "CodeQuality", DiagnosticSeverity.Warning, isEnabledByDefault: true);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => 
        ImmutableArray.Create(Rule);

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.MethodDeclaration);
    }

    private void AnalyzeNode(SyntaxNodeAnalysisContext context)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        
        // –õ–æ–≥–∏–∫–∞ –ø–æ–∏—Å–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
        // ...
    }
}
```

### 2.2 –°–æ–∑–¥–∞—Ç—å Code Fix –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è

```csharp
// CodeFixes/ExtractToUtilityClassCodeFix.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(ExtractToUtilityClassCodeFix))]
public class ExtractToUtilityClassCodeFix : CodeFixProvider
{
    public sealed override ImmutableArray<string> FixableDiagnosticIds =>
        ImmutableArray.Create(DuplicateCodeAnalyzer.DiagnosticId);

    public sealed override FixAllProvider GetFixAllProvider() =>
        WellKnownFixAllProviders.BatchFixer;

    public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
    {
        var diagnostic = context.Diagnostics.First();
        var diagnosticSpan = diagnostic.Location.SourceSpan;

        context.RegisterCodeFix(
            CodeAction.Create(
                title: "Extract to utility class",
                createChangedSolution: c => ExtractToUtilityClassAsync(context.Document, diagnosticSpan, c),
                equivalenceKey: "ExtractToUtilityClass"),
            diagnostic);
    }

    private async Task<Solution> ExtractToUtilityClassAsync(Document document, TextSpan span, CancellationToken cancellationToken)
    {
        // –õ–æ–≥–∏–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤ —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–π –∫–ª–∞—Å—Å
        // ...
    }
}
```

## –≠—Ç–∞–ø 3: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –±–æ–ª—å—à–∏—Ö –∫–ª–∞—Å—Å–æ–≤

### 3.1 –°–æ–∑–¥–∞—Ç—å Analyzer –¥–ª—è –±–æ–ª—å—à–∏—Ö –∫–ª–∞—Å—Å–æ–≤

```csharp
// Analyzers/LargeClassAnalyzer.cs
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class LargeClassAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "CD002";
    
    private static readonly LocalizableString Title = "Class is too large";
    private static readonly LocalizableString MessageFormat = "Class '{0}' has {1} lines and {2} methods. Consider splitting it.";
    
    private static readonly DiagnosticDescriptor Rule = new(
        DiagnosticId, Title, MessageFormat, 
        "CodeQuality", DiagnosticSeverity.Warning, isEnabledByDefault: true);

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSyntaxNodeAction(AnalyzeClass, SyntaxKind.ClassDeclaration);
    }

    private void AnalyzeClass(SyntaxNodeAnalysisContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        
        var lineCount = classDeclaration.GetLocation().GetLineSpan().EndLinePosition.Line - 
                       classDeclaration.GetLocation().GetLineSpan().StartLinePosition.Line;
        
        var methodCount = classDeclaration.Members.OfType<MethodDeclarationSyntax>().Count();
        
        if (lineCount > 400 || methodCount > 15)
        {
            var diagnostic = Diagnostic.Create(Rule, classDeclaration.Identifier.GetLocation(), 
                classDeclaration.Identifier.ValueText, lineCount, methodCount);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
```

### 3.2 –°–æ–∑–¥–∞—Ç—å Code Fix –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è

```csharp
// CodeFixes/SplitLargeClassCodeFix.cs
public class SplitLargeClassCodeFix : CodeFixProvider
{
    public sealed override ImmutableArray<string> FixableDiagnosticIds =>
        ImmutableArray.Create(LargeClassAnalyzer.DiagnosticId);

    public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
    {
        var diagnostic = context.Diagnostics.First();
        
        context.RegisterCodeFix(
            CodeAction.Create(
                title: "Split class into smaller classes",
                createChangedSolution: c => SplitClassAsync(context.Document, diagnostic, c),
                equivalenceKey: "SplitLargeClass"),
            diagnostic);
    }

    private async Task<Solution> SplitClassAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken)
    {
        // AI-–∞–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–ª–∞—Å—Å–∞
        var classDeclaration = await GetClassDeclaration(document, diagnostic, cancellationToken);
        
        // –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–ª–∞–Ω–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
        var splitPlan = await AnalyzeClassStructure(classDeclaration);
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
        return await ExecuteSplitPlan(document, splitPlan, cancellationToken);
    }
}
```

## –≠—Ç–∞–ø 4: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å –ø–æ–º–æ—â—å—é AI

### 4.1 –°–æ–∑–¥–∞—Ç—å AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

```csharp
// Services/RefactoringAIAssistant.cs
public class RefactoringAIAssistant
{
    private readonly OpenAIClient _openAIClient;
    
    public async Task<RefactoringPlan> AnalyzeClassAsync(ClassDeclarationSyntax classDeclaration)
    {
        var classCode = classDeclaration.ToFullString();
        
        var prompt = $@"
        Analyze this C# class and suggest a refactoring plan:
        
        {classCode}
        
        Provide:
        1. Suggested class splits
        2. Methods to extract
        3. New file structure
        4. Dependencies to consider
        ";
        
        var response = await _openAIClient.GetChatCompletionAsync(prompt);
        return ParseRefactoringPlan(response);
    }
    
    public async Task<string> GenerateRoslynCodeAsync(RefactoringPlan plan)
    {
        var prompt = $@"
        Generate Roslyn code to execute this refactoring plan:
        
        {JsonSerializer.Serialize(plan)}
        
        Return only the C# code that uses Roslyn APIs.
        ";
        
        return await _openAIClient.GetChatCompletionAsync(prompt);
    }
}
```

### 4.2 –°–æ–∑–¥–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥

```csharp
// Services/AutomatedRefactoringService.cs
public class AutomatedRefactoringService
{
    private readonly RefactoringAIAssistant _aiAssistant;
    private readonly Workspace _workspace;
    
    public async Task<Solution> RefactorLargeClassAsync(Document document, ClassDeclarationSyntax classDeclaration)
    {
        // 1. AI –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–ª–∞—Å—Å
        var plan = await _aiAssistant.AnalyzeClassAsync(classDeclaration);
        
        // 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç Roslyn –∫–æ–¥
        var roslynCode = await _aiAssistant.GenerateRoslynCodeAsync(plan);
        
        // 3. –í—ã–ø–æ–ª–Ω—è–µ—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥
        return await ExecuteRoslynCode(document, roslynCode);
    }
    
    private async Task<Solution> ExecuteRoslynCode(Document document, string roslynCode)
    {
        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ Roslyn –∫–æ–¥–∞
        // ...
    }
}
```

## –≠—Ç–∞–ø 5: CI/CD –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

### 5.1 –°–æ–∑–¥–∞—Ç—å GitHub Action –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞

```yaml
# .github/workflows/auto-refactor.yml
name: Auto Refactor

on:
  push:
    branches: [ develop ]
  pull_request:
    branches: [ main ]

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 9.0.x
    
    - name: Install dependencies
      run: dotnet restore
    
    - name: Run analyzers
      run: dotnet build --verbosity normal
    
    - name: Run auto-refactor
      run: dotnet run --project tools/RefactoringTool
    
    - name: Create PR if changes
      uses: peter-evans/create-pull-request@v4
      with:
        title: 'Auto-refactor: Split large classes and remove duplicates'
        body: 'Automated refactoring based on code analysis'
        branch: auto-refactor/$(date +%Y%m%d-%H%M%S)
```

### 5.2 –°–æ–∑–¥–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏

```csharp
// tools/RefactoringTool/Program.cs
class Program
{
    static async Task Main(string[] args)
    {
        var workspace = MSBuildWorkspace.Create();
        var solution = await workspace.OpenSolutionAsync(args[0]);
        
        var refactoringService = new AutomatedRefactoringService();
        
        foreach (var project in solution.Projects)
        {
            foreach (var document in project.Documents)
            {
                var syntaxTree = await document.GetSyntaxTreeAsync();
                var root = await syntaxTree.GetRootAsync();
                
                // –ù–∞–π—Ç–∏ –±–æ–ª—å—à–∏–µ –∫–ª–∞—Å—Å—ã
                var largeClasses = root.DescendantNodes()
                    .OfType<ClassDeclarationSyntax>()
                    .Where(c => IsLargeClass(c));
                
                foreach (var largeClass in largeClasses)
                {
                    solution = await refactoringService.RefactorLargeClassAsync(document, largeClass);
                }
            }
        }
        
        workspace.TryApplyChanges(solution);
    }
}
```

## –≠—Ç–∞–ø 6: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –º–µ—Ç—Ä–∏–∫–∏

### 6.1 –°–æ–∑–¥–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞

```csharp
// Services/CodeQualityMetrics.cs
public class CodeQualityMetrics
{
    public async Task<QualityReport> GenerateReportAsync(Solution solution)
    {
        var report = new QualityReport();
        
        foreach (var project in solution.Projects)
        {
            foreach (var document in project.Documents)
            {
                var syntaxTree = await document.GetSyntaxTreeAsync();
                var root = await syntaxTree.GetRootAsync();
                
                report.TotalLines += root.GetText().Lines.Count;
                report.TotalClasses += root.DescendantNodes().OfType<ClassDeclarationSyntax>().Count();
                report.TotalMethods += root.DescendantNodes().OfType<MethodDeclarationSyntax>().Count();
                
                // –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
                report.ComplexClasses += root.DescendantNodes()
                    .OfType<ClassDeclarationSyntax>()
                    .Count(c => IsComplexClass(c));
            }
        }
        
        return report;
    }
}
```

## –†–µ—Ü–µ–ø—Ç "–º–∏–Ω–∏–º—É–º –º–∞–≥–∏–∏" –¥–ª—è ClubDoorman

### 1. –ü–æ–∫—Ä—ã–≤–∞–µ–º —Ç–µ—Å—Ç–∞–º–∏ –∫—Ä–∏—Ç–∏—á–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
```bash
# –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
dotnet test --collect:"XPlat Code Coverage"
```

### 2. –°—Ç—Ä–æ–∏–º call graph
```bash
# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Sourcegraph –∏–ª–∏ IDE –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
```

### 3. LLM-prompt –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
```
"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–ª–∞—Å—Å MessageHandler.cs (1034 —Å—Ç—Ä–æ–∫–∏) –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ –ø–ª–∞–Ω —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –Ω–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏"
```

### 4. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Roslyn –∫–æ–¥
```csharp
// AI –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç Roslyn –∫–æ–¥ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞
var workspace = MSBuildWorkspace.Create();
var solution = await workspace.OpenSolutionAsync("ClubDoorman.sln");
// ... –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥
```

### 5. –ü—Ä–æ–≥–æ–Ω—è–µ–º –Ω–∞ —á–µ—Ä–Ω–æ–≤–æ–π –≤–µ—Ç–∫–µ
```bash
git checkout -b auto-refactor
dotnet build
dotnet test
```

### 6. –ê–≤—Ç–æ–ø—Ä–∏–Ω—è—Ç–∏–µ —Ç–æ–ª—å–∫–æ –∑–µ–ª–µ–Ω—ã—Ö diff-–æ–≤
```yaml
# –í CI –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
- name: Verify refactoring
  run: |
    dotnet build
    dotnet test
    if [ $? -eq 0 ]; then
      echo "Refactoring successful"
    else
      echo "Refactoring failed, reverting"
      git reset --hard HEAD~1
    fi
```

## –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

### –î–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏:
- –†—É—á–Ω–æ–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: 3-4 –Ω–µ–¥–µ–ª–∏
- –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫ –æ—à–∏–±–æ–∫
- –°–ª–æ–∂–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### –ü–æ—Å–ª–µ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏:
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: 1-2 –¥–Ω—è
- –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫ –æ—à–∏–±–æ–∫
- –ü–æ–ª–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ —Ç–µ—Å—Ç–∞–º–∏
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫–∞—Ç–∞

### –ú–µ—Ç—Ä–∏–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞:
- –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–æ–≤: <300 —Å—Ç—Ä–æ–∫
- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–æ–¥–æ–≤: <15
- –¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: <20
- –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞: 0%

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–î–ª—è C# –ø—Ä–æ–µ–∫—Ç–∞ ClubDoorman –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –º–æ—â–Ω—É—é —Å–∏—Å—Ç–µ–º—É –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞, –∫–æ—Ç–æ—Ä–∞—è:

1. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏** —É—Å—Ç—Ä–∞–Ω—è–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
2. **AI-–ø–æ–º–æ—â—å—é** –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –±–æ–ª—å—à–∏—Ö –∫–ª–∞—Å—Å–æ–≤
3. **Roslyn** –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Ç–æ—á–Ω—ã–µ AST-–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
4. **CI/CD** –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∫–∞—á–µ—Å—Ç–≤–æ

–≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∑–∞ 1-2 –¥–Ω—è –≤–º–µ—Å—Ç–æ 3-4 –Ω–µ–¥–µ–ª—å —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º —Ä–∏—Å–∫–æ–º –æ—à–∏–±–æ–∫. 