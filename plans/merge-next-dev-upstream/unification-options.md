# Варианты унификации MessageService

## Текущее состояние
- Два метода с дублированием логики
- Разные подходы к обработке ошибок
- Сохранена совместимость

## Вариант 1: Унификация через Request Objects (Рекомендуемый)

### Изменить ваш метод:
```csharp
public async Task<Message?> SendWelcomeMessageAsync(SendWelcomeMessageRequest request)
{
    // Проверяем, отключены ли приветствия
    if (Config.DisableWelcome)
    {
        _logger.LogDebug("Приветственные сообщения отключены (DOORMAN_DISABLE_WELCOME=true)");
        return null; // Вместо исключения
    }
    
    // Вся логика создания сообщения здесь
    // Автоматическое удаление через 20 секунд
}
```

### Совместимый метод:
```csharp
public async Task<Message?> SendWelcomeMessageAsync(User user, Chat chat, string reason, CancellationToken cancellationToken)
{
    var request = new SendWelcomeMessageRequest(user, chat, reason, cancellationToken);
    return await SendWelcomeMessageAsync(request);
}
```

### Преимущества:
- ✅ Единая логика
- ✅ Сохранена ваша архитектура Request Objects
- ✅ Принято поведение Мамая (null вместо исключения)
- ✅ Нет дублирования кода

### Риски:
- ❌ Изменение поведения вашего метода
- ❌ Возможные регрессии в существующем коде

## Вариант 2: Оставить как есть

### Преимущества:
- ✅ Безопасность - нет изменений в существующем коде
- ✅ Сохранена ваша архитектура
- ✅ Принято поведение Мамая

### Недостатки:
- ❌ Дублирование логики
- ❌ Два метода для одной функции

## Рекомендация

### Для безопасного перехода:
1. **Сначала протестировать** текущую реализацию
2. **Найти все места** использования вашего метода
3. **Постепенно мигрировать** на новый подход
4. **Добавить тесты** для проверки поведения

### Или оставить как есть:
- Если дублирование не критично
- Если безопасность важнее унификации 